<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PacMan_CANOpen: Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PacMan_CANOpen
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___c_o__driver.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Driver<div class="ingroups"><a class="el" href="group___c_o___c_a_nopen.html">CANopen stack</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___c_o__data_types"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__data_types.html">Data types</a></td></tr>
<tr class="memdesc:group___c_o__data_types"><td class="mdescLeft">&#160;</td><td class="mdescRight">According to Misra C. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:_c_o__driver_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_o__driver_8h.html">CO_driver.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:_c_o__driver__target_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_o__driver__target_8h.html">CO_driver_target.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:_references_2_c_a_n___files_2_c_o__driver_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_references_2_c_a_n___files_2_c_o__driver_8h.html">CO_driver.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:_references_2_c_a_n___files_2_c_o__driver__target_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h.html">CO_driver_target.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_o___c_a_nrx_msg__t.html">CO_CANrxMsg_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga499212a81f94cdb9ac84f5f8d082b95b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga499212a81f94cdb9ac84f5f8d082b95b">CO_CANsetConfigurationMode</a> (void *CANdriverState)</td></tr>
<tr class="separator:ga499212a81f94cdb9ac84f5f8d082b95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad654edfa651bf7b68263913786697200"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#gad654edfa651bf7b68263913786697200">CO_CANsetNormalMode</a> (<a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> *CANmodule)</td></tr>
<tr class="separator:gad654edfa651bf7b68263913786697200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6aeb96ec4dbb8750d8c9d8f6bd0f1e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_o__types_8h.html#a1cb2d3466eb0c6d267f3b5ff1a0d9532">CO_ReturnError_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#gaa6aeb96ec4dbb8750d8c9d8f6bd0f1e2">CO_CANmodule_init</a> (<a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> *CANmodule, void *CANdriverState, <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> rxArray[], uint16_t rxSize, <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> txArray[], uint16_t txSize, uint16_t CANbitRate)</td></tr>
<tr class="separator:gaa6aeb96ec4dbb8750d8c9d8f6bd0f1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6f60f9da27dda0c9b3950c4e96bd687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#gac6f60f9da27dda0c9b3950c4e96bd687">CO_CANmodule_disable</a> (<a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> *CANmodule)</td></tr>
<tr class="separator:gac6f60f9da27dda0c9b3950c4e96bd687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff8768d283f511756924e07f89b76d26"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#gaff8768d283f511756924e07f89b76d26">CO_CANrxMsg_readIdent</a> (const <a class="el" href="struct_c_o___c_a_nrx_msg__t.html">CO_CANrxMsg_t</a> *rxMsg)</td></tr>
<tr class="separator:gaff8768d283f511756924e07f89b76d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ead9e6716366d0b1481a9ffe9bbe34d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_o__types_8h.html#a1cb2d3466eb0c6d267f3b5ff1a0d9532">CO_ReturnError_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga9ead9e6716366d0b1481a9ffe9bbe34d">CO_CANrxBufferInit</a> (<a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> *CANmodule, uint16_t index, uint16_t ident, uint16_t mask, <a class="el" href="group___c_o__data_types.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a> rtr, void *object, void(*pFunct)(void *object, const <a class="el" href="struct_c_o___c_a_nrx_msg__t.html">CO_CANrxMsg_t</a> *message))</td></tr>
<tr class="separator:ga9ead9e6716366d0b1481a9ffe9bbe34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01e2ee79e7e3a8b321dac831e7e00976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga01e2ee79e7e3a8b321dac831e7e00976">CO_CANtxBufferInit</a> (<a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> *CANmodule, uint16_t index, uint16_t ident, <a class="el" href="group___c_o__data_types.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a> rtr, uint8_t noOfBytes, <a class="el" href="group___c_o__data_types.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a> syncFlag)</td></tr>
<tr class="separator:ga01e2ee79e7e3a8b321dac831e7e00976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4664a9f5d547cb0605a9e929fb079f2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_o__types_8h.html#a1cb2d3466eb0c6d267f3b5ff1a0d9532">CO_ReturnError_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga4664a9f5d547cb0605a9e929fb079f2e">CO_CANsend</a> (<a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> *CANmodule, <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> *buffer)</td></tr>
<tr class="separator:ga4664a9f5d547cb0605a9e929fb079f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbeac85cbf513162b11fc3d0717b0753"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#gabbeac85cbf513162b11fc3d0717b0753">CO_CANclearPendingSyncPDOs</a> (<a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> *CANmodule)</td></tr>
<tr class="separator:gabbeac85cbf513162b11fc3d0717b0753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa9e96d1772f3d7b37aa12732e9e4cea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#gafa9e96d1772f3d7b37aa12732e9e4cea">CO_CANverifyErrors</a> (<a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> *CANmodule)</td></tr>
<tr class="separator:gafa9e96d1772f3d7b37aa12732e9e4cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5e1af799bd59ed0a39495241ce6f5e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#gae5e1af799bd59ed0a39495241ce6f5e3">CO_CANinterrupt</a> (<a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> *CANmodule)</td></tr>
<tr class="separator:gae5e1af799bd59ed0a39495241ce6f5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Critical sections</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpacf2c07a1805f83f6469703e99bcf042"></a>CANopenNode is designed to run in different threads, as described in README. Threads are implemented differently in different systems. In microcontrollers threads are interrupts with different priorities, for example. It is necessary to protect sections, where different threads access to the same resource. In simple systems interrupts or scheduler may be temporary disabled between access to the shared resource. Otherwise mutexes or semaphores can be used.</p>
<h4><a class="anchor" id="autotoc_md4"></a>
Reentrant functions.</h4>
<p>Functions <a class="el" href="group___c_o__driver.html#ga4664a9f5d547cb0605a9e929fb079f2e">CO_CANsend()</a> from C_driver.h, <a class="el" href="group___c_o___emergency.html#ga9c9b7258698aadf6e9365bc0d1324be8">CO_errorReport()</a> from CO_Emergency.h and <a class="el" href="group___c_o___emergency.html#ga14947a08d1c68446ee3356f00159174f">CO_errorReset()</a> from CO_Emergency.h may be called from different threads. Critical sections must be protected. Eather by disabling scheduler or interrupts or by mutexes or semaphores.</p>
<h4><a class="anchor" id="autotoc_md5"></a>
Object Dictionary variables.</h4>
<p>In general, there are two threads, which accesses OD variables: mainline and timer. CANopenNode initialization and SDO server runs in mainline. PDOs runs in faster timer thread. Processing of PDOs must not be interrupted by mainline. Mainline thread must protect sections, which accesses the same OD variables as timer thread. This care must also take the application. Note that not all variables are allowed to be mapped to PDOs, so they may not need to be protected. SDO server protects sections with access to OD variables.</p>
<h4><a class="anchor" id="autotoc_md6"></a>
CAN receive thread.</h4>
<p>It partially processes received CAN data and puts them into appropriate objects. Objects are later processed. It does not need protection of critical sections. There is one circumstance, where CANrx should be disabled: After presence of SYNC message on CANopen bus, CANrx should be temporary disabled until all receive PDOs are processed. See also CO_SYNC.h file and CO_SYNC_initCallback() function. </p>
</td></tr>
<tr class="memitem:ga7566ee901bbf1a0d76d771d72d2f826f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga7566ee901bbf1a0d76d771d72d2f826f">CO_LOCK_CAN_SEND</a>()</td></tr>
<tr class="separator:ga7566ee901bbf1a0d76d771d72d2f826f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga511a5a0bf905c2207d5c9e26d35fe3cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga511a5a0bf905c2207d5c9e26d35fe3cc">CO_UNLOCK_CAN_SEND</a>()</td></tr>
<tr class="separator:ga511a5a0bf905c2207d5c9e26d35fe3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3052a84235f56d535a14705e0cfda799"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga3052a84235f56d535a14705e0cfda799">CO_LOCK_EMCY</a>()</td></tr>
<tr class="separator:ga3052a84235f56d535a14705e0cfda799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga720a798f2bf7fe20d9c95a212b4df417"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga720a798f2bf7fe20d9c95a212b4df417">CO_UNLOCK_EMCY</a>()</td></tr>
<tr class="separator:ga720a798f2bf7fe20d9c95a212b4df417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3850830931ced2bd3d7e15821572bbcc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga3850830931ced2bd3d7e15821572bbcc">CO_LOCK_OD</a>()</td></tr>
<tr class="separator:ga3850830931ced2bd3d7e15821572bbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2477f5d24fd31a9f4052cf451b87809f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga2477f5d24fd31a9f4052cf451b87809f">CO_UNLOCK_OD</a>()</td></tr>
<tr class="separator:ga2477f5d24fd31a9f4052cf451b87809f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Syncronisation functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp7d487514a38116083bcf977fffd5573d"></a>syncronisation for message buffer for communication between CAN receive and message processing threads.</p>
<p>If receive function runs inside IRQ, no further synchronsiation is needed. Otherwise, some kind of synchronsiation has to be included. The following example uses GCC builtin memory barrier __sync_synchronize(). A comprehensive list can be found here: <a href="https://gist.github.com/leo-yuriev/ba186a6bf5cf3a27bae7">https://gist.github.com/leo-yuriev/ba186a6bf5cf3a27bae7</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#define CANrxMemoryBarrier() {__sync_synchronize();}</span></div>
</div><!-- fragment --> </td></tr>
<tr class="memitem:ga0cf4099f9e716769492013b92fdd5a50"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga0cf4099f9e716769492013b92fdd5a50">CANrxMemoryBarrier</a>()</td></tr>
<tr class="separator:ga0cf4099f9e716769492013b92fdd5a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga535c175d53f76b78ac586dd7e313e764"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga535c175d53f76b78ac586dd7e313e764">IS_CANrxNew</a>(rxNew)&#160;&#160;&#160;((uintptr_t)rxNew)</td></tr>
<tr class="separator:ga535c175d53f76b78ac586dd7e313e764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9658047fbf7d12298cfa627a4db1fbb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#gaf9658047fbf7d12298cfa627a4db1fbb">SET_CANrxNew</a>(rxNew)&#160;&#160;&#160;{<a class="el" href="group___c_o__driver.html#ga0cf4099f9e716769492013b92fdd5a50">CANrxMemoryBarrier</a>(); rxNew = (void*)1L;}</td></tr>
<tr class="separator:gaf9658047fbf7d12298cfa627a4db1fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe9d8f1d14567463a15d31924fc28876"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#gafe9d8f1d14567463a15d31924fc28876">CLEAR_CANrxNew</a>(rxNew)&#160;&#160;&#160;{<a class="el" href="group___c_o__driver.html#ga0cf4099f9e716769492013b92fdd5a50">CANrxMemoryBarrier</a>(); rxNew = (void*)0L;}</td></tr>
<tr class="separator:gafe9d8f1d14567463a15d31924fc28876"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Critical sections</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpacf2c07a1805f83f6469703e99bcf042"></a>CANopenNode is designed to run in different threads, as described in README. Threads are implemented differently in different systems. In microcontrollers threads are interrupts with different priorities, for example. It is necessary to protect sections, where different threads access to the same resource. In simple systems interrupts or scheduler may be temporary disabled between access to the shared resource. Otherwise mutexes or semaphores can be used.</p>
<h4><a class="anchor" id="autotoc_md49"></a>
Reentrant functions.</h4>
<p>Functions <a class="el" href="group___c_o__driver.html#ga4664a9f5d547cb0605a9e929fb079f2e">CO_CANsend()</a> from C_driver.h, <a class="el" href="group___c_o___emergency.html#ga9c9b7258698aadf6e9365bc0d1324be8">CO_errorReport()</a> from CO_Emergency.h and <a class="el" href="group___c_o___emergency.html#ga14947a08d1c68446ee3356f00159174f">CO_errorReset()</a> from CO_Emergency.h may be called from different threads. Critical sections must be protected. Eather by disabling scheduler or interrupts or by mutexes or semaphores.</p>
<h4><a class="anchor" id="autotoc_md50"></a>
Object Dictionary variables.</h4>
<p>In general, there are two threads, which accesses OD variables: mainline and timer. CANopenNode initialization and SDO server runs in mainline. PDOs runs in faster timer thread. Processing of PDOs must not be interrupted by mainline. Mainline thread must protect sections, which accesses the same OD variables as timer thread. This care must also take the application. Note that not all variables are allowed to be mapped to PDOs, so they may not need to be protected. SDO server protects sections with access to OD variables.</p>
<h4><a class="anchor" id="autotoc_md51"></a>
CAN receive thread.</h4>
<p>It partially processes received CAN data and puts them into appropriate objects. Objects are later processed. It does not need protection of critical sections. There is one circumstance, where CANrx should be disabled: After presence of SYNC message on CANopen bus, CANrx should be temporary disabled until all receive PDOs are processed. See also CO_SYNC.h file and CO_SYNC_initCallback() function. </p>
</td></tr>
<tr class="memitem:ga7566ee901bbf1a0d76d771d72d2f826f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga7566ee901bbf1a0d76d771d72d2f826f">CO_LOCK_CAN_SEND</a>()</td></tr>
<tr class="separator:ga7566ee901bbf1a0d76d771d72d2f826f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga511a5a0bf905c2207d5c9e26d35fe3cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga511a5a0bf905c2207d5c9e26d35fe3cc">CO_UNLOCK_CAN_SEND</a>()</td></tr>
<tr class="separator:ga511a5a0bf905c2207d5c9e26d35fe3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3052a84235f56d535a14705e0cfda799"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga3052a84235f56d535a14705e0cfda799">CO_LOCK_EMCY</a>()</td></tr>
<tr class="separator:ga3052a84235f56d535a14705e0cfda799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga720a798f2bf7fe20d9c95a212b4df417"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga720a798f2bf7fe20d9c95a212b4df417">CO_UNLOCK_EMCY</a>()</td></tr>
<tr class="separator:ga720a798f2bf7fe20d9c95a212b4df417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3850830931ced2bd3d7e15821572bbcc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga3850830931ced2bd3d7e15821572bbcc">CO_LOCK_OD</a>()</td></tr>
<tr class="separator:ga3850830931ced2bd3d7e15821572bbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2477f5d24fd31a9f4052cf451b87809f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga2477f5d24fd31a9f4052cf451b87809f">CO_UNLOCK_OD</a>()</td></tr>
<tr class="separator:ga2477f5d24fd31a9f4052cf451b87809f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Syncronisation functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp7d487514a38116083bcf977fffd5573d"></a>syncronisation for message buffer for communication between CAN receive and message processing threads.</p>
<p>If receive function runs inside IRQ, no further synchronsiation is needed. Otherwise, some kind of synchronsiation has to be included. The following example uses GCC builtin memory barrier __sync_synchronize(). A comprehensive list can be found here: <a href="https://gist.github.com/leo-yuriev/ba186a6bf5cf3a27bae7">https://gist.github.com/leo-yuriev/ba186a6bf5cf3a27bae7</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#define CANrxMemoryBarrier() {__sync_synchronize();}</span></div>
</div><!-- fragment --> </td></tr>
<tr class="memitem:ga0cf4099f9e716769492013b92fdd5a50"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga0cf4099f9e716769492013b92fdd5a50">CANrxMemoryBarrier</a>()</td></tr>
<tr class="separator:ga0cf4099f9e716769492013b92fdd5a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga535c175d53f76b78ac586dd7e313e764"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#ga535c175d53f76b78ac586dd7e313e764">IS_CANrxNew</a>(rxNew)&#160;&#160;&#160;((uintptr_t)rxNew)</td></tr>
<tr class="separator:ga535c175d53f76b78ac586dd7e313e764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9658047fbf7d12298cfa627a4db1fbb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#gaf9658047fbf7d12298cfa627a4db1fbb">SET_CANrxNew</a>(rxNew)&#160;&#160;&#160;{<a class="el" href="group___c_o__driver.html#ga0cf4099f9e716769492013b92fdd5a50">CANrxMemoryBarrier</a>(); rxNew = (void*)1L;}</td></tr>
<tr class="separator:gaf9658047fbf7d12298cfa627a4db1fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe9d8f1d14567463a15d31924fc28876"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o__driver.html#gafe9d8f1d14567463a15d31924fc28876">CLEAR_CANrxNew</a>(rxNew)&#160;&#160;&#160;{<a class="el" href="group___c_o__driver.html#ga0cf4099f9e716769492013b92fdd5a50">CANrxMemoryBarrier</a>(); rxNew = (void*)0L;}</td></tr>
<tr class="separator:gafe9d8f1d14567463a15d31924fc28876"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Microcontroller specific code for CANopenNode.</p>
<p>This file contains type definitions, functions and macros for:</p><ul>
<li>Basic data types.</li>
<li>Receive and transmit buffers for CANopen messages.</li>
<li>Interaction with CAN module on the microcontroller.</li>
<li>CAN receive and transmit interrupts.</li>
</ul>
<p>This file is not only a CAN driver. There are no classic CAN queues for CAN messages. This file provides direct connection with other CANopen objects. It tries to provide fast responses and tries to avoid unnecessary calculations and memory consumptions.</p>
<p><a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> contains an array of <em>Received message objects</em> (of type <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a>) and an array of <em>Transmit message objects</em> (of type <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a>). Each CANopen communication object owns one member in one of the arrays. For example Heartbeat producer generates one CANopen transmitting object, so it has reserved one member in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> array. SYNC module may produce sync or consume sync, so it has reserved one member in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> and one member in <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> array.</p>
<h3><a class="anchor" id="autotoc_md0"></a>
Reception of CAN messages.</h3>
<p>Before CAN messages can be received, each member in <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> must be initialized. <a class="el" href="group___c_o__driver.html#ga9ead9e6716366d0b1481a9ffe9bbe34d">CO_CANrxBufferInit()</a> is called by CANopen module, which uses specific member. For example <a class="el" href="group___c_o___h_bconsumer.html">Heartbeat consumer</a> uses multiple members in <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> array. (It monitors multiple heartbeat messages from remote nodes.) It must call <a class="el" href="group___c_o__driver.html#ga9ead9e6716366d0b1481a9ffe9bbe34d">CO_CANrxBufferInit()</a> multiple times.</p>
<p>Main arguments to the <a class="el" href="group___c_o__driver.html#ga9ead9e6716366d0b1481a9ffe9bbe34d">CO_CANrxBufferInit()</a> function are CAN identifier and a pointer to callback function. Those two arguments (and some others) are copied to the member of the <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> array.</p>
<p>Callback function is a function, specified by specific CANopen module (for example by <a class="el" href="group___c_o___h_bconsumer.html">Heartbeat consumer</a>). Each CANopen module defines own callback function. Callback function will process the received CAN message. It will copy the necessary data from CAN message to proper place. It may also trigger additional task, which will further process the received message. Callback function must be fast and must only make the necessary calculations and copying.</p>
<p>Received CAN messages are processed by CAN receive interrupt function. After CAN message is received, function first tries to find matching CAN identifier from <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> array. If found, then a corresponding callback function is called.</p>
<p>Callback function accepts two parameters:</p><ul>
<li>object is pointer to object registered by <a class="el" href="group___c_o__driver.html#ga9ead9e6716366d0b1481a9ffe9bbe34d">CO_CANrxBufferInit()</a>.</li>
<li>msg is pointer to CAN message of type <a class="el" href="struct_c_o___c_a_nrx_msg__t.html">CO_CANrxMsg_t</a>.</li>
</ul>
<p>Callback function must return <a class="el" href="_references_2_c_a_n___files_2_c_o__types_8h.html#a1cb2d3466eb0c6d267f3b5ff1a0d9532">CO_ReturnError_t</a>: CO_ERROR_NO, CO_ERROR_RX_OVERFLOW, CO_ERROR_RX_PDO_OVERFLOW, CO_ERROR_RX_MSG_LENGTH or CO_ERROR_RX_PDO_LENGTH.</p>
<h3><a class="anchor" id="autotoc_md1"></a>
Transmission of CAN messages.</h3>
<p>Before CAN messages can be transmitted, each member in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> must be initialized. <a class="el" href="group___c_o__driver.html#ga01e2ee79e7e3a8b321dac831e7e00976">CO_CANtxBufferInit()</a> is called by CANopen module, which uses specific member. For example Heartbeat producer must initialize it's member in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> array.</p>
<p><a class="el" href="group___c_o__driver.html#ga01e2ee79e7e3a8b321dac831e7e00976">CO_CANtxBufferInit()</a> returns a pointer of type <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a>, which contains buffer where CAN message data can be written. CAN message is send with calling <a class="el" href="group___c_o__driver.html#ga4664a9f5d547cb0605a9e929fb079f2e">CO_CANsend()</a> function. If at that moment CAN transmit buffer inside microcontroller's CAN module is free, message is copied directly to CAN module. Otherwise <a class="el" href="group___c_o__driver.html#ga4664a9f5d547cb0605a9e929fb079f2e">CO_CANsend()</a> function sets <em>bufferFull</em> flag to true. Message will be then sent by CAN TX interrupt as soon as CAN module is freed. Until message is not copied to CAN module, its contents must not change. There may be multiple <em>bufferFull</em> flags in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> array set to true. In that case messages with lower index inside array will be sent first.</p>
<p>Microcontroller specific code for CANopenNode.</p>
<p>This file contains type definitions, functions and macros for:</p><ul>
<li>Basic data types.</li>
<li>Receive and transmit buffers for CANopen messages.</li>
<li>Interaction with CAN module on the microcontroller.</li>
<li>CAN receive and transmit interrupts.</li>
</ul>
<p>This file is not only a CAN driver. There are no classic CAN queues for CAN messages. This file provides direct connection with other CANopen objects. It tries to provide fast responses and tries to avoid unnecessary calculations and memory consumptions.</p>
<p><a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> contains an array of <em>Received message objects</em> (of type <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a>) and an array of <em>Transmit message objects</em> (of type <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a>). Each CANopen communication object owns one member in one of the arrays. For example Heartbeat producer generates one CANopen transmitting object, so it has reserved one member in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> array. SYNC module may produce sync or consume sync, so it has reserved one member in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> and one member in <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> array.</p>
<h3><a class="anchor" id="autotoc_md2"></a>
Reception of CAN messages.</h3>
<p>Before CAN messages can be received, each member in <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> must be initialized. <a class="el" href="group___c_o__driver.html#ga9ead9e6716366d0b1481a9ffe9bbe34d">CO_CANrxBufferInit()</a> is called by CANopen module, which uses specific member. For example <a class="el" href="group___c_o___h_bconsumer.html">Heartbeat consumer</a> uses multiple members in <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> array. (It monitors multiple heartbeat messages from remote nodes.) It must call <a class="el" href="group___c_o__driver.html#ga9ead9e6716366d0b1481a9ffe9bbe34d">CO_CANrxBufferInit()</a> multiple times.</p>
<p>Main arguments to the <a class="el" href="group___c_o__driver.html#ga9ead9e6716366d0b1481a9ffe9bbe34d">CO_CANrxBufferInit()</a> function are CAN identifier and a pointer to callback function. Those two arguments (and some others) are copied to the member of the <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> array.</p>
<p>Callback function is a function, specified by specific CANopen module (for example by <a class="el" href="group___c_o___h_bconsumer.html">Heartbeat consumer</a>). Each CANopen module defines own callback function. Callback function will process the received CAN message. It will copy the necessary data from CAN message to proper place. It may also trigger additional task, which will further process the received message. Callback function must be fast and must only make the necessary calculations and copying.</p>
<p>Received CAN messages are processed by CAN receive interrupt function. After CAN message is received, function first tries to find matching CAN identifier from <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> array. If found, then a corresponding callback function is called.</p>
<p>Callback function accepts two parameters:</p><ul>
<li>object is pointer to object registered by <a class="el" href="group___c_o__driver.html#ga9ead9e6716366d0b1481a9ffe9bbe34d">CO_CANrxBufferInit()</a>.</li>
<li>msg is pointer to CAN message of type <a class="el" href="struct_c_o___c_a_nrx_msg__t.html">CO_CANrxMsg_t</a>.</li>
</ul>
<p>Callback function must return <a class="el" href="_references_2_c_a_n___files_2_c_o__types_8h.html#a1cb2d3466eb0c6d267f3b5ff1a0d9532">CO_ReturnError_t</a>: CO_ERROR_NO, CO_ERROR_RX_OVERFLOW, CO_ERROR_RX_PDO_OVERFLOW, CO_ERROR_RX_MSG_LENGTH or CO_ERROR_RX_PDO_LENGTH.</p>
<h3><a class="anchor" id="autotoc_md3"></a>
Transmission of CAN messages.</h3>
<p>Before CAN messages can be transmitted, each member in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> must be initialized. <a class="el" href="group___c_o__driver.html#ga01e2ee79e7e3a8b321dac831e7e00976">CO_CANtxBufferInit()</a> is called by CANopen module, which uses specific member. For example Heartbeat producer must initialize it's member in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> array.</p>
<p><a class="el" href="group___c_o__driver.html#ga01e2ee79e7e3a8b321dac831e7e00976">CO_CANtxBufferInit()</a> returns a pointer of type <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a>, which contains buffer where CAN message data can be written. CAN message is send with calling <a class="el" href="group___c_o__driver.html#ga4664a9f5d547cb0605a9e929fb079f2e">CO_CANsend()</a> function. If at that moment CAN transmit buffer inside microcontroller's CAN module is free, message is copied directly to CAN module. Otherwise <a class="el" href="group___c_o__driver.html#ga4664a9f5d547cb0605a9e929fb079f2e">CO_CANsend()</a> function sets <em>bufferFull</em> flag to true. Message will be then sent by CAN TX interrupt as soon as CAN module is freed. Until message is not copied to CAN module, its contents must not change. There may be multiple <em>bufferFull</em> flags in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> array set to true. In that case messages with lower index inside array will be sent first.</p>
<p>Microcontroller specific code for CANopenNode.</p>
<p>This file contains type definitions, functions and macros for:</p><ul>
<li>Basic data types.</li>
<li>Receive and transmit buffers for CANopen messages.</li>
<li>Interaction with CAN module on the microcontroller.</li>
<li>CAN receive and transmit interrupts.</li>
</ul>
<p>This file is not only a CAN driver. There are no classic CAN queues for CAN messages. This file provides direct connection with other CANopen objects. It tries to provide fast responses and tries to avoid unnecessary calculations and memory consumptions.</p>
<p><a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> contains an array of <em>Received message objects</em> (of type <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a>) and an array of <em>Transmit message objects</em> (of type <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a>). Each CANopen communication object owns one member in one of the arrays. For example Heartbeat producer generates one CANopen transmitting object, so it has reserved one member in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> array. SYNC module may produce sync or consume sync, so it has reserved one member in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> and one member in <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> array.</p>
<h3><a class="anchor" id="autotoc_md45"></a>
Reception of CAN messages.</h3>
<p>Before CAN messages can be received, each member in <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> must be initialized. <a class="el" href="group___c_o__driver.html#ga9ead9e6716366d0b1481a9ffe9bbe34d">CO_CANrxBufferInit()</a> is called by CANopen module, which uses specific member. For example <a class="el" href="group___c_o___h_bconsumer.html">Heartbeat consumer</a> uses multiple members in <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> array. (It monitors multiple heartbeat messages from remote nodes.) It must call <a class="el" href="group___c_o__driver.html#ga9ead9e6716366d0b1481a9ffe9bbe34d">CO_CANrxBufferInit()</a> multiple times.</p>
<p>Main arguments to the <a class="el" href="group___c_o__driver.html#ga9ead9e6716366d0b1481a9ffe9bbe34d">CO_CANrxBufferInit()</a> function are CAN identifier and a pointer to callback function. Those two arguments (and some others) are copied to the member of the <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> array.</p>
<p>Callback function is a function, specified by specific CANopen module (for example by <a class="el" href="group___c_o___h_bconsumer.html">Heartbeat consumer</a>). Each CANopen module defines own callback function. Callback function will process the received CAN message. It will copy the necessary data from CAN message to proper place. It may also trigger additional task, which will further process the received message. Callback function must be fast and must only make the necessary calculations and copying.</p>
<p>Received CAN messages are processed by CAN receive interrupt function. After CAN message is received, function first tries to find matching CAN identifier from <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> array. If found, then a corresponding callback function is called.</p>
<p>Callback function accepts two parameters:</p><ul>
<li>object is pointer to object registered by <a class="el" href="group___c_o__driver.html#ga9ead9e6716366d0b1481a9ffe9bbe34d">CO_CANrxBufferInit()</a>.</li>
<li>msg is pointer to CAN message of type <a class="el" href="struct_c_o___c_a_nrx_msg__t.html">CO_CANrxMsg_t</a>.</li>
</ul>
<p>Callback function must return <a class="el" href="_references_2_c_a_n___files_2_c_o__types_8h.html#a1cb2d3466eb0c6d267f3b5ff1a0d9532">CO_ReturnError_t</a>: CO_ERROR_NO, CO_ERROR_RX_OVERFLOW, CO_ERROR_RX_PDO_OVERFLOW, CO_ERROR_RX_MSG_LENGTH or CO_ERROR_RX_PDO_LENGTH.</p>
<h3><a class="anchor" id="autotoc_md46"></a>
Transmission of CAN messages.</h3>
<p>Before CAN messages can be transmitted, each member in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> must be initialized. <a class="el" href="group___c_o__driver.html#ga01e2ee79e7e3a8b321dac831e7e00976">CO_CANtxBufferInit()</a> is called by CANopen module, which uses specific member. For example Heartbeat producer must initialize it's member in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> array.</p>
<p><a class="el" href="group___c_o__driver.html#ga01e2ee79e7e3a8b321dac831e7e00976">CO_CANtxBufferInit()</a> returns a pointer of type <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a>, which contains buffer where CAN message data can be written. CAN message is send with calling <a class="el" href="group___c_o__driver.html#ga4664a9f5d547cb0605a9e929fb079f2e">CO_CANsend()</a> function. If at that moment CAN transmit buffer inside microcontroller's CAN module is free, message is copied directly to CAN module. Otherwise <a class="el" href="group___c_o__driver.html#ga4664a9f5d547cb0605a9e929fb079f2e">CO_CANsend()</a> function sets <em>bufferFull</em> flag to true. Message will be then sent by CAN TX interrupt as soon as CAN module is freed. Until message is not copied to CAN module, its contents must not change. There may be multiple <em>bufferFull</em> flags in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> array set to true. In that case messages with lower index inside array will be sent first.</p>
<p>Microcontroller specific code for CANopenNode.</p>
<p>This file contains type definitions, functions and macros for:</p><ul>
<li>Basic data types.</li>
<li>Receive and transmit buffers for CANopen messages.</li>
<li>Interaction with CAN module on the microcontroller.</li>
<li>CAN receive and transmit interrupts.</li>
</ul>
<p>This file is not only a CAN driver. There are no classic CAN queues for CAN messages. This file provides direct connection with other CANopen objects. It tries to provide fast responses and tries to avoid unnecessary calculations and memory consumptions.</p>
<p><a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> contains an array of <em>Received message objects</em> (of type <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a>) and an array of <em>Transmit message objects</em> (of type <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a>). Each CANopen communication object owns one member in one of the arrays. For example Heartbeat producer generates one CANopen transmitting object, so it has reserved one member in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> array. SYNC module may produce sync or consume sync, so it has reserved one member in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> and one member in <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> array.</p>
<h3><a class="anchor" id="autotoc_md47"></a>
Reception of CAN messages.</h3>
<p>Before CAN messages can be received, each member in <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> must be initialized. <a class="el" href="group___c_o__driver.html#ga9ead9e6716366d0b1481a9ffe9bbe34d">CO_CANrxBufferInit()</a> is called by CANopen module, which uses specific member. For example <a class="el" href="group___c_o___h_bconsumer.html">Heartbeat consumer</a> uses multiple members in <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> array. (It monitors multiple heartbeat messages from remote nodes.) It must call <a class="el" href="group___c_o__driver.html#ga9ead9e6716366d0b1481a9ffe9bbe34d">CO_CANrxBufferInit()</a> multiple times.</p>
<p>Main arguments to the <a class="el" href="group___c_o__driver.html#ga9ead9e6716366d0b1481a9ffe9bbe34d">CO_CANrxBufferInit()</a> function are CAN identifier and a pointer to callback function. Those two arguments (and some others) are copied to the member of the <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> array.</p>
<p>Callback function is a function, specified by specific CANopen module (for example by <a class="el" href="group___c_o___h_bconsumer.html">Heartbeat consumer</a>). Each CANopen module defines own callback function. Callback function will process the received CAN message. It will copy the necessary data from CAN message to proper place. It may also trigger additional task, which will further process the received message. Callback function must be fast and must only make the necessary calculations and copying.</p>
<p>Received CAN messages are processed by CAN receive interrupt function. After CAN message is received, function first tries to find matching CAN identifier from <a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a> array. If found, then a corresponding callback function is called.</p>
<p>Callback function accepts two parameters:</p><ul>
<li>object is pointer to object registered by <a class="el" href="group___c_o__driver.html#ga9ead9e6716366d0b1481a9ffe9bbe34d">CO_CANrxBufferInit()</a>.</li>
<li>msg is pointer to CAN message of type <a class="el" href="struct_c_o___c_a_nrx_msg__t.html">CO_CANrxMsg_t</a>.</li>
</ul>
<p>Callback function must return <a class="el" href="_references_2_c_a_n___files_2_c_o__types_8h.html#a1cb2d3466eb0c6d267f3b5ff1a0d9532">CO_ReturnError_t</a>: CO_ERROR_NO, CO_ERROR_RX_OVERFLOW, CO_ERROR_RX_PDO_OVERFLOW, CO_ERROR_RX_MSG_LENGTH or CO_ERROR_RX_PDO_LENGTH.</p>
<h3><a class="anchor" id="autotoc_md48"></a>
Transmission of CAN messages.</h3>
<p>Before CAN messages can be transmitted, each member in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> must be initialized. <a class="el" href="group___c_o__driver.html#ga01e2ee79e7e3a8b321dac831e7e00976">CO_CANtxBufferInit()</a> is called by CANopen module, which uses specific member. For example Heartbeat producer must initialize it's member in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> array.</p>
<p><a class="el" href="group___c_o__driver.html#ga01e2ee79e7e3a8b321dac831e7e00976">CO_CANtxBufferInit()</a> returns a pointer of type <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a>, which contains buffer where CAN message data can be written. CAN message is send with calling <a class="el" href="group___c_o__driver.html#ga4664a9f5d547cb0605a9e929fb079f2e">CO_CANsend()</a> function. If at that moment CAN transmit buffer inside microcontroller's CAN module is free, message is copied directly to CAN module. Otherwise <a class="el" href="group___c_o__driver.html#ga4664a9f5d547cb0605a9e929fb079f2e">CO_CANsend()</a> function sets <em>bufferFull</em> flag to true. Message will be then sent by CAN TX interrupt as soon as CAN module is freed. Until message is not copied to CAN module, its contents must not change. There may be multiple <em>bufferFull</em> flags in <a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> array set to true. In that case messages with lower index inside array will be sent first. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga0cf4099f9e716769492013b92fdd5a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cf4099f9e716769492013b92fdd5a50">&#9670;&nbsp;</a></span>CANrxMemoryBarrier <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CANrxMemoryBarrier</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Memory barrier </p>

<p class="definition">Definition at line <a class="el" href="_c_o__driver__target_8h_source.html#l00188">188</a> of file <a class="el" href="_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="ga0cf4099f9e716769492013b92fdd5a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cf4099f9e716769492013b92fdd5a50">&#9670;&nbsp;</a></span>CANrxMemoryBarrier <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CANrxMemoryBarrier</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Memory barrier </p>

<p class="definition">Definition at line <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html#l00188">188</a> of file <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="gafe9d8f1d14567463a15d31924fc28876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe9d8f1d14567463a15d31924fc28876">&#9670;&nbsp;</a></span>CLEAR_CANrxNew <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CLEAR_CANrxNew</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rxNew</td><td>)</td>
          <td>&#160;&#160;&#160;{<a class="el" href="group___c_o__driver.html#ga0cf4099f9e716769492013b92fdd5a50">CANrxMemoryBarrier</a>(); rxNew = (void*)0L;}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear new message flag </p>

<p class="definition">Definition at line <a class="el" href="_c_o__driver__target_8h_source.html#l00194">194</a> of file <a class="el" href="_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="gafe9d8f1d14567463a15d31924fc28876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe9d8f1d14567463a15d31924fc28876">&#9670;&nbsp;</a></span>CLEAR_CANrxNew <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CLEAR_CANrxNew</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rxNew</td><td>)</td>
          <td>&#160;&#160;&#160;{<a class="el" href="group___c_o__driver.html#ga0cf4099f9e716769492013b92fdd5a50">CANrxMemoryBarrier</a>(); rxNew = (void*)0L;}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear new message flag </p>

<p class="definition">Definition at line <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html#l00194">194</a> of file <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="ga7566ee901bbf1a0d76d771d72d2f826f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7566ee901bbf1a0d76d771d72d2f826f">&#9670;&nbsp;</a></span>CO_LOCK_CAN_SEND <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CO_LOCK_CAN_SEND</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock critical section in <a class="el" href="group___c_o__driver.html#ga4664a9f5d547cb0605a9e929fb079f2e">CO_CANsend()</a> </p>

<p class="definition">Definition at line <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html#l00163">163</a> of file <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="ga7566ee901bbf1a0d76d771d72d2f826f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7566ee901bbf1a0d76d771d72d2f826f">&#9670;&nbsp;</a></span>CO_LOCK_CAN_SEND <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CO_LOCK_CAN_SEND</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock critical section in <a class="el" href="group___c_o__driver.html#ga4664a9f5d547cb0605a9e929fb079f2e">CO_CANsend()</a> </p>

<p class="definition">Definition at line <a class="el" href="_c_o__driver__target_8h_source.html#l00163">163</a> of file <a class="el" href="_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="ga3052a84235f56d535a14705e0cfda799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3052a84235f56d535a14705e0cfda799">&#9670;&nbsp;</a></span>CO_LOCK_EMCY <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CO_LOCK_EMCY</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock critical section in <a class="el" href="group___c_o___emergency.html#ga9c9b7258698aadf6e9365bc0d1324be8">CO_errorReport()</a> or <a class="el" href="group___c_o___emergency.html#ga14947a08d1c68446ee3356f00159174f">CO_errorReset()</a> </p>

<p class="definition">Definition at line <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html#l00166">166</a> of file <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="ga3052a84235f56d535a14705e0cfda799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3052a84235f56d535a14705e0cfda799">&#9670;&nbsp;</a></span>CO_LOCK_EMCY <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CO_LOCK_EMCY</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock critical section in <a class="el" href="group___c_o___emergency.html#ga9c9b7258698aadf6e9365bc0d1324be8">CO_errorReport()</a> or <a class="el" href="group___c_o___emergency.html#ga14947a08d1c68446ee3356f00159174f">CO_errorReset()</a> </p>

<p class="definition">Definition at line <a class="el" href="_c_o__driver__target_8h_source.html#l00166">166</a> of file <a class="el" href="_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="ga3850830931ced2bd3d7e15821572bbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3850830931ced2bd3d7e15821572bbcc">&#9670;&nbsp;</a></span>CO_LOCK_OD <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CO_LOCK_OD</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock critical section when accessing Object Dictionary </p>

<p class="definition">Definition at line <a class="el" href="_c_o__driver__target_8h_source.html#l00169">169</a> of file <a class="el" href="_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="ga3850830931ced2bd3d7e15821572bbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3850830931ced2bd3d7e15821572bbcc">&#9670;&nbsp;</a></span>CO_LOCK_OD <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CO_LOCK_OD</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock critical section when accessing Object Dictionary </p>

<p class="definition">Definition at line <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html#l00169">169</a> of file <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="ga511a5a0bf905c2207d5c9e26d35fe3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga511a5a0bf905c2207d5c9e26d35fe3cc">&#9670;&nbsp;</a></span>CO_UNLOCK_CAN_SEND <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CO_UNLOCK_CAN_SEND</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlock critical section in <a class="el" href="group___c_o__driver.html#ga4664a9f5d547cb0605a9e929fb079f2e">CO_CANsend()</a> </p>

<p class="definition">Definition at line <a class="el" href="_c_o__driver__target_8h_source.html#l00164">164</a> of file <a class="el" href="_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="ga511a5a0bf905c2207d5c9e26d35fe3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga511a5a0bf905c2207d5c9e26d35fe3cc">&#9670;&nbsp;</a></span>CO_UNLOCK_CAN_SEND <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CO_UNLOCK_CAN_SEND</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlock critical section in <a class="el" href="group___c_o__driver.html#ga4664a9f5d547cb0605a9e929fb079f2e">CO_CANsend()</a> </p>

<p class="definition">Definition at line <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html#l00164">164</a> of file <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="ga720a798f2bf7fe20d9c95a212b4df417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga720a798f2bf7fe20d9c95a212b4df417">&#9670;&nbsp;</a></span>CO_UNLOCK_EMCY <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CO_UNLOCK_EMCY</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlock critical section in <a class="el" href="group___c_o___emergency.html#ga9c9b7258698aadf6e9365bc0d1324be8">CO_errorReport()</a> or <a class="el" href="group___c_o___emergency.html#ga14947a08d1c68446ee3356f00159174f">CO_errorReset()</a> </p>

<p class="definition">Definition at line <a class="el" href="_c_o__driver__target_8h_source.html#l00167">167</a> of file <a class="el" href="_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="ga720a798f2bf7fe20d9c95a212b4df417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga720a798f2bf7fe20d9c95a212b4df417">&#9670;&nbsp;</a></span>CO_UNLOCK_EMCY <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CO_UNLOCK_EMCY</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlock critical section in <a class="el" href="group___c_o___emergency.html#ga9c9b7258698aadf6e9365bc0d1324be8">CO_errorReport()</a> or <a class="el" href="group___c_o___emergency.html#ga14947a08d1c68446ee3356f00159174f">CO_errorReset()</a> </p>

<p class="definition">Definition at line <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html#l00167">167</a> of file <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="ga2477f5d24fd31a9f4052cf451b87809f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2477f5d24fd31a9f4052cf451b87809f">&#9670;&nbsp;</a></span>CO_UNLOCK_OD <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CO_UNLOCK_OD</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unock critical section when accessing Object Dictionary </p>

<p class="definition">Definition at line <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html#l00170">170</a> of file <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="ga2477f5d24fd31a9f4052cf451b87809f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2477f5d24fd31a9f4052cf451b87809f">&#9670;&nbsp;</a></span>CO_UNLOCK_OD <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CO_UNLOCK_OD</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unock critical section when accessing Object Dictionary </p>

<p class="definition">Definition at line <a class="el" href="_c_o__driver__target_8h_source.html#l00170">170</a> of file <a class="el" href="_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="ga535c175d53f76b78ac586dd7e313e764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga535c175d53f76b78ac586dd7e313e764">&#9670;&nbsp;</a></span>IS_CANrxNew <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IS_CANrxNew</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rxNew</td><td>)</td>
          <td>&#160;&#160;&#160;((uintptr_t)rxNew)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if new message has arrived </p>

<p class="definition">Definition at line <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html#l00190">190</a> of file <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="ga535c175d53f76b78ac586dd7e313e764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga535c175d53f76b78ac586dd7e313e764">&#9670;&nbsp;</a></span>IS_CANrxNew <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IS_CANrxNew</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rxNew</td><td>)</td>
          <td>&#160;&#160;&#160;((uintptr_t)rxNew)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if new message has arrived </p>

<p class="definition">Definition at line <a class="el" href="_c_o__driver__target_8h_source.html#l00190">190</a> of file <a class="el" href="_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="gaf9658047fbf7d12298cfa627a4db1fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9658047fbf7d12298cfa627a4db1fbb">&#9670;&nbsp;</a></span>SET_CANrxNew <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SET_CANrxNew</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rxNew</td><td>)</td>
          <td>&#160;&#160;&#160;{<a class="el" href="group___c_o__driver.html#ga0cf4099f9e716769492013b92fdd5a50">CANrxMemoryBarrier</a>(); rxNew = (void*)1L;}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set new message flag </p>

<p class="definition">Definition at line <a class="el" href="_c_o__driver__target_8h_source.html#l00192">192</a> of file <a class="el" href="_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<a id="gaf9658047fbf7d12298cfa627a4db1fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9658047fbf7d12298cfa627a4db1fbb">&#9670;&nbsp;</a></span>SET_CANrxNew <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SET_CANrxNew</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rxNew</td><td>)</td>
          <td>&#160;&#160;&#160;{<a class="el" href="group___c_o__driver.html#ga0cf4099f9e716769492013b92fdd5a50">CANrxMemoryBarrier</a>(); rxNew = (void*)1L;}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set new message flag </p>

<p class="definition">Definition at line <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html#l00192">192</a> of file <a class="el" href="_references_2_c_a_n___files_2_c_o__driver__target_8h_source.html">CO_driver_target.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabbeac85cbf513162b11fc3d0717b0753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbeac85cbf513162b11fc3d0717b0753">&#9670;&nbsp;</a></span>CO_CANclearPendingSyncPDOs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CO_CANclearPendingSyncPDOs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> *&#160;</td>
          <td class="paramname"><em>CANmodule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all synchronous TPDOs from CAN module transmit buffers.</p>
<p>CANopen allows synchronous PDO communication only inside time between SYNC message and SYNC Window. If time is outside this window, new synchronous PDOs must not be sent and all pending sync TPDOs, which may be on CAN TX buffers, must be cleared.</p>
<p>This function checks (and aborts transmission if necessary) CAN TX buffers when it is called. Function should be called by the stack in the moment, when SYNC time was just passed out of synchronous window.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CANmodule</td><td>This object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_c_o__driver_8c_source.html#l00283">283</a> of file <a class="el" href="_c_o__driver_8c_source.html">CO_driver.c</a>.</p>

</div>
</div>
<a id="gae5e1af799bd59ed0a39495241ce6f5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5e1af799bd59ed0a39495241ce6f5e3">&#9670;&nbsp;</a></span>CO_CANinterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CO_CANinterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> *&#160;</td>
          <td class="paramname"><em>CANmodule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receives and transmits CAN messages.</p>
<p>Function must be called directly from high priority CAN interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CANmodule</td><td>This object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_c_o__driver_8c_source.html#l00378">378</a> of file <a class="el" href="_c_o__driver_8c_source.html">CO_driver.c</a>.</p>

</div>
</div>
<a id="gac6f60f9da27dda0c9b3950c4e96bd687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6f60f9da27dda0c9b3950c4e96bd687">&#9670;&nbsp;</a></span>CO_CANmodule_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CO_CANmodule_disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> *&#160;</td>
          <td class="paramname"><em>CANmodule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switch off CANmodule. Call at program exit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CANmodule</td><td>CAN module object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_c_o__driver_8c_source.html#l00154">154</a> of file <a class="el" href="_c_o__driver_8c_source.html">CO_driver.c</a>.</p>

</div>
</div>
<a id="gaa6aeb96ec4dbb8750d8c9d8f6bd0f1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6aeb96ec4dbb8750d8c9d8f6bd0f1e2">&#9670;&nbsp;</a></span>CO_CANmodule_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_c_o__types_8h.html#a1cb2d3466eb0c6d267f3b5ff1a0d9532">CO_ReturnError_t</a> CO_CANmodule_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> *&#160;</td>
          <td class="paramname"><em>CANmodule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CANdriverState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_o___c_a_nrx__t.html">CO_CANrx_t</a>&#160;</td>
          <td class="paramname"><em>rxArray</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a>&#160;</td>
          <td class="paramname"><em>txArray</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>txSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>CANbitRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize CAN module object.</p>
<p>Function must be called in the communication reset section. CAN module must be in Configuration Mode before.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CANmodule</td><td>This object will be initialized. </td></tr>
    <tr><td class="paramname">CANdriverState</td><td>User-provided CAN module structure.. </td></tr>
    <tr><td class="paramname">rxArray</td><td>Array for handling received CAN messages </td></tr>
    <tr><td class="paramname">rxSize</td><td>Size of the above array. Must be equal to number of receiving CAN objects. </td></tr>
    <tr><td class="paramname">txArray</td><td>Array for handling transmitting CAN messages </td></tr>
    <tr><td class="paramname">txSize</td><td>Size of the above array. Must be equal to number of transmitting CAN objects. </td></tr>
    <tr><td class="paramname">CANbitRate</td><td>Valid values are (in kbps): 10, 20, 50, 125, 250, 500, 800, 1000. If value is illegal, bitrate defaults to 125.</td></tr>
  </table>
  </dd>
</dl>
<p>Return <a class="el" href="_references_2_c_a_n___files_2_c_o__types_8h.html#a1cb2d3466eb0c6d267f3b5ff1a0d9532">CO_ReturnError_t</a>: CO_ERROR_NO or CO_ERROR_ILLEGAL_ARGUMENT. </p>

<p class="definition">Definition at line <a class="el" href="_c_o__driver_8c_source.html#l00055">55</a> of file <a class="el" href="_c_o__driver_8c_source.html">CO_driver.c</a>.</p>

</div>
</div>
<a id="ga9ead9e6716366d0b1481a9ffe9bbe34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ead9e6716366d0b1481a9ffe9bbe34d">&#9670;&nbsp;</a></span>CO_CANrxBufferInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_c_o__types_8h.html#a1cb2d3466eb0c6d267f3b5ff1a0d9532">CO_ReturnError_t</a> CO_CANrxBufferInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> *&#160;</td>
          <td class="paramname"><em>CANmodule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ident</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_o__data_types.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a>&#160;</td>
          <td class="paramname"><em>rtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *object, const <a class="el" href="struct_c_o___c_a_nrx_msg__t.html">CO_CANrxMsg_t</a> *message)&#160;</td>
          <td class="paramname"><em>pFunct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure CAN message receive buffer.</p>
<p>Function configures specific CAN receive buffer. It sets CAN identifier and connects buffer with specific object. Function must be called for each member in <em>rxArray</em> from <a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CANmodule</td><td>This object. </td></tr>
    <tr><td class="paramname">index</td><td>Index of the specific buffer in <em>rxArray</em>. </td></tr>
    <tr><td class="paramname">ident</td><td>11-bit standard CAN Identifier. </td></tr>
    <tr><td class="paramname">mask</td><td>11-bit mask for identifier. Most usually set to 0x7FF. Received message (rcvMsg) will be accepted if the following condition is true: (((rcvMsgId ^ ident) &amp; mask) == 0). </td></tr>
    <tr><td class="paramname">rtr</td><td>If true, 'Remote Transmit Request' messages will be accepted. </td></tr>
    <tr><td class="paramname">object</td><td>CANopen object, to which buffer is connected. It will be used as an argument to pFunct. Its type is (void), pFunct will change its type back to the correct object type. </td></tr>
    <tr><td class="paramname">pFunct</td><td>Pointer to function, which will be called, if received CAN message matches the identifier. It must be fast function.</td></tr>
  </table>
  </dd>
</dl>
<p>Return <a class="el" href="_references_2_c_a_n___files_2_c_o__types_8h.html#a1cb2d3466eb0c6d267f3b5ff1a0d9532">CO_ReturnError_t</a>: CO_ERROR_NO CO_ERROR_ILLEGAL_ARGUMENT or CO_ERROR_OUT_OF_MEMORY (not enough masks for configuration). </p>

<p class="definition">Definition at line <a class="el" href="_c_o__driver_8c_source.html#l00167">167</a> of file <a class="el" href="_c_o__driver_8c_source.html">CO_driver.c</a>.</p>

</div>
</div>
<a id="gaff8768d283f511756924e07f89b76d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff8768d283f511756924e07f89b76d26">&#9670;&nbsp;</a></span>CO_CANrxMsg_readIdent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t CO_CANrxMsg_readIdent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_o___c_a_nrx_msg__t.html">CO_CANrxMsg_t</a> *&#160;</td>
          <td class="paramname"><em>rxMsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read CAN identifier from received message</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rxMsg</td><td>Pointer to received message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>11-bit CAN standard identifier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_c_o__driver_8c_source.html#l00161">161</a> of file <a class="el" href="_c_o__driver_8c_source.html">CO_driver.c</a>.</p>

</div>
</div>
<a id="ga4664a9f5d547cb0605a9e929fb079f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4664a9f5d547cb0605a9e929fb079f2e">&#9670;&nbsp;</a></span>CO_CANsend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_c_o__types_8h.html#a1cb2d3466eb0c6d267f3b5ff1a0d9532">CO_ReturnError_t</a> CO_CANsend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> *&#160;</td>
          <td class="paramname"><em>CANmodule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send CAN message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CANmodule</td><td>This object. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to transmit buffer, returned by <a class="el" href="group___c_o__driver.html#ga01e2ee79e7e3a8b321dac831e7e00976">CO_CANtxBufferInit()</a>. Data bytes must be written in buffer before function call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="_references_2_c_a_n___files_2_c_o__types_8h.html#a1cb2d3466eb0c6d267f3b5ff1a0d9532">CO_ReturnError_t</a>: CO_ERROR_NO, CO_ERROR_TX_OVERFLOW or CO_ERROR_TX_PDO_WINDOW (Synchronous TPDO is outside window). </dd></dl>

<p class="definition">Definition at line <a class="el" href="_c_o__driver_8c_source.html#l00237">237</a> of file <a class="el" href="_c_o__driver_8c_source.html">CO_driver.c</a>.</p>

</div>
</div>
<a id="ga499212a81f94cdb9ac84f5f8d082b95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga499212a81f94cdb9ac84f5f8d082b95b">&#9670;&nbsp;</a></span>CO_CANsetConfigurationMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CO_CANsetConfigurationMode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CANdriverState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request CAN configuration (stopped) mode and <em>wait</em> untill it is set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CANdriverState</td><td>User-provided CAN module structure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_c_o__driver_8c_source.html#l00038">38</a> of file <a class="el" href="_c_o__driver_8c_source.html">CO_driver.c</a>.</p>

</div>
</div>
<a id="gad654edfa651bf7b68263913786697200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad654edfa651bf7b68263913786697200">&#9670;&nbsp;</a></span>CO_CANsetNormalMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CO_CANsetNormalMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> *&#160;</td>
          <td class="paramname"><em>CANmodule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request CAN normal (opearational) mode and <em>wait</em> untill it is set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CANmodule</td><td>This object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_c_o__driver_8c_source.html#l00047">47</a> of file <a class="el" href="_c_o__driver_8c_source.html">CO_driver.c</a>.</p>

</div>
</div>
<a id="ga01e2ee79e7e3a8b321dac831e7e00976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01e2ee79e7e3a8b321dac831e7e00976">&#9670;&nbsp;</a></span>CO_CANtxBufferInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_o___c_a_ntx__t.html">CO_CANtx_t</a>* CO_CANtxBufferInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> *&#160;</td>
          <td class="paramname"><em>CANmodule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ident</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_o__data_types.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a>&#160;</td>
          <td class="paramname"><em>rtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noOfBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_o__data_types.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a>&#160;</td>
          <td class="paramname"><em>syncFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure CAN message transmit buffer.</p>
<p>Function configures specific CAN transmit buffer. Function must be called for each member in <em>txArray</em> from <a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CANmodule</td><td>This object. </td></tr>
    <tr><td class="paramname">index</td><td>Index of the specific buffer in <em>txArray</em>. </td></tr>
    <tr><td class="paramname">ident</td><td>11-bit standard CAN Identifier. </td></tr>
    <tr><td class="paramname">rtr</td><td>If true, 'Remote Transmit Request' messages will be transmitted. </td></tr>
    <tr><td class="paramname">noOfBytes</td><td>Length of CAN message in bytes (0 to 8 bytes). </td></tr>
    <tr><td class="paramname">syncFlag</td><td>This flag bit is used for synchronous TPDO messages. If it is set, message will not be sent, if curent time is outside synchronous window.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to CAN transmit message buffer. 8 bytes data array inside buffer should be written, before <a class="el" href="group___c_o__driver.html#ga4664a9f5d547cb0605a9e929fb079f2e">CO_CANsend()</a> function is called. Zero is returned in case of wrong arguments. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_c_o__driver_8c_source.html#l00207">207</a> of file <a class="el" href="_c_o__driver_8c_source.html">CO_driver.c</a>.</p>

</div>
</div>
<a id="gafa9e96d1772f3d7b37aa12732e9e4cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa9e96d1772f3d7b37aa12732e9e4cea">&#9670;&nbsp;</a></span>CO_CANverifyErrors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CO_CANverifyErrors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_o___c_a_nmodule__t.html">CO_CANmodule_t</a> *&#160;</td>
          <td class="paramname"><em>CANmodule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verify all errors of CAN module.</p>
<p>Function is called directly from <a class="el" href="_c_o___emergency_8c.html#aff607e6d9b26d2fe5874aeb456481024">CO_EM_process()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CANmodule</td><td>This object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_c_o__driver_8c_source.html#l00319">319</a> of file <a class="el" href="_c_o__driver_8c_source.html">CO_driver.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
